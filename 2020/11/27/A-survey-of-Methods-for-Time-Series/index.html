<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>A_survey_of_Methods_for_Time_Series | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="时间序列变化点检测方法概述        A Survey of Methods for Time Series Change Point Detection Abs:变更点是时间序列数据中的突然变化。这种突然的变化可能表示状态之间发生的过渡。变化点的检测对于时间序列的建模和预测很有用，并且可以在医疗状况监视，气候变化检测，语音和图像分析以及人类活动分析等应用领域中找到。这篇调查文章列举，分类和比">
<meta property="og:type" content="article">
<meta property="og:title" content="A_survey_of_Methods_for_Time_Series">
<meta property="og:url" content="http://example.com/2020/11/27/A-survey-of-Methods-for-Time-Series/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="时间序列变化点检测方法概述        A Survey of Methods for Time Series Change Point Detection Abs:变更点是时间序列数据中的突然变化。这种突然的变化可能表示状态之间发生的过渡。变化点的检测对于时间序列的建模和预测很有用，并且可以在医疗状况监视，气候变化检测，语音和图像分析以及人类活动分析等应用领域中找到。这篇调查文章列举，分类和比">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-11-27T02:48:30.000Z">
<meta property="article:modified_time" content="2020-11-27T05:40:03.084Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/11/27/A-survey-of-Methods-for-Time-Series/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-27 13:40:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">A_survey_of_Methods_for_Time_Series</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-11-27T02:48:30.000Z" title="Created 2020-11-27 10:48:30">2020-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-11-27T05:40:03.084Z" title="Updated 2020-11-27 13:40:03">2020-11-27</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>时间序列变化点检测方法概述<br>        A Survey of Methods for Time Series Change Point Detection</p>
<h2 id="Abs"><a href="#Abs" class="headerlink" title="Abs:"></a>Abs:</h2><p>变更点是时间序列数据中的突然变化。这种突然的变化可能表示状态之间发生的过渡。变化点的检测对于时间序列的建模和预测很有用，并且可以在医疗状况监视，气候变化检测，语音和图像分析以及人类活动分析等应用领域中找到。这篇调查文章列举，分类和比较了许多建议用来检测时间序列变化点的方法。所检查的方法包括已引入和评估的有监督和无监督算法。我们介绍了几个标准来比较算法。最后，我们提出了一些重大挑战供社区考虑。<br>        Change points are abrupt variations in time series data. Such abrupt changes may represent transitions that occur between states. Detection of change points is useful in modelling and prediction of time series and is found in application areas such as medical condition monitoring, climate change detection, speech and image analysis, and human activity analysis. This survey article enumerates, categorizes, and compares many of the methods that have been proposed to detect change points in time series. The methods examined include both supervised and unsupervised algorithms that have been introduced and evaluated. We introduce several criteria to compare the algorithms. Finally, we present some grand challenges for the community to consider.</p>
<p>关键词 变更点检测；时间序列数据；分割;机器学习；数据挖掘<br>        Keywords Change point detection; Time series data; Segmentation; Machine learning; Data mining</p>
<h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>时间序列分析在医学，航空航天，金融，商业，气象和娱乐等各个领域中变得越来越重要。时间序列数据是随时间推移的测量序列，描述了系统的行为。由于外部事件和/或动力学/分布的内部系统变化，这些行为会随着时间而变化[1]。更改点检测（CPD）是在时间序列的属性更改时发现数据突然更改的问题[2]。分割，边缘检测，事件检测和异常检测是类似的概念，偶尔会应用到变化点检测。变更点检测与变更点估计或变更点挖掘的众所周知的问题密切相关[3] [4] [5]。但是，与CPD不同，更改点估计会尝试对时间序列中的已知更改进行建模和解释，而不是确定已发生更改。变更点估计的重点是描述已知变更的性质和程度。<br>        Time series analysis has become increasingly important in diverse fields including medicine, aerospace, finance, business, meteorology, and entertainment. Time series data are sequences of measurements over time describing the behavior of systems. These behaviors can change over time due to external events and/or internal systematic changes in dynamics/ distribution [1]. Change point detection (CPD) is the problem of finding abrupt changes in data when a property of the time series changes [2]. Segmentation, edge detection, event detection and anomaly detection are similar concepts which are occasionally applied as well as change point detection. Change point detection is closely related to the well-known problem of change point estimation or change point mining [3][4][5]. Unlike CPD, however, change point estimation tries to model and interpret known changes in time series rather than identifying that a change has occurred. The focus of change point estimates is to describe the nature and degree of the known change.</p>
<p>在本文中，我们调查了变更点检测的主题，并研究了该领域的最新研究。在过去的几十年中，已经在数据挖掘，统计和计算机科学领域研究了CPD。该问题涵盖了广泛的现实世界中的问题。这是一些激励人心的例子。<br>        In this paper, we survey the topic of change point detection and examine recent research in this area. CPD has been studied over the last several decades in the fields of data mining, statistics, and computer science. This problem covers a broad range of real-world problems. Here are some motivating examples.</p>
<p>医疗状况监视：对患者健康的连续监视涉及对诸如心率，脑电图（EEG）和心电图（ECG）等生理变量的趋势检测，以执行自动化的实时监视。研究研究针对特定医学问题（例如睡眠问题，癫痫症，磁共振成像（MRI）解释以及对大脑活动的理解）进行变化点检测[6] [7] [8] [9]。<br>        Medical condition monitoring: Continuous monitoring of patient health involves trend detection in physiological variables such as heart rate, electroencephalogram (EEG), and electrocardiogram (ECG) in order to perform automated, real-time monitoring. Research studies investigate change point detection for specific medical issues such as sleep problems, epilepsy, magnetic resonance imaging (MRI) interpretation, and understanding of brain activities [6][7][8][9].</p>
<p>气候变化检测：由于气候变化的可能发生和大气中温室气体的增加，在过去的几十年中，利用变化点检测进行气候分析，监测和预测方法变得越来越重要[10] [11] [ 12]。<br>        Climate change detection: Climate analysis, monitoring, and prediction methods that utilize change point detection have become increasingly important over the last few decades due to the possible occurrence of climate change and the increase of greenhouse gases in the atmosphere [10][11][12].</p>
<p>语音识别：语音识别代表将口头语音转换为单词或文本的过程。变更点检测方法在这里用于音频分割和识别静音，句子，单词和噪声之间的边界[13] [14]。<br>        Speech recognition: Speech recognition represents the process of converting spoken speech utterances to words or text. Change point detection methods are applied here for audio segmentation and recognizing boundaries between silence, sentences, words, and noise [13] [14].</p>
<p>图像分析：研究人员和从业人员会随时间收集图像数据或视频数据，以进行基于视频的监视。诸如安全漏洞之类的突发事件的检测可以表述为一个变更点问题。这里，在每个时间点的观察是图像的数字编码[15]。<br>        Image analysis: Researchers and practitioners collect image data over time, or video data, for video-based surveillance. The detection of abrupt events, such as security breaches, can be formulated as a change-point problem. Here, the observation at each time point is the digital encoding of an image [15].</p>
<p>人类活动分析：基于观察到的来自智能家居或移动设备的传感器数据的特征，检测活动断点或转变可以表示为变更点检测。这些变更点可用于细分活动，与人互动同时最大程度地减少干扰，提供活动意识服务以及检测行为变化，从而提供有关健康状况的见解[13-20]。<br>        Human activity analysis: Detecting activity breakpoints or transitions based on characteristics of observed sensor data from smart homes or mobile devices can be formulated as change point detection. These change points are useful for segmenting activities, interacting with humans while minimizing interruptions, providing activity-aware services, and detecting changes in behavior that provide insights on health status [13–20].</p>
<p>在本次调查中，我们将解释变化点检测的问题，并探索如何将不同的监督和非监督方法用于检测时间序列数据中的变化点。我们将根据其成本，局限性和性能来比较和对比研究的技术。最后，我们讨论了研究中的差距，总结了变更点应用程序中出现的挑战，并为继续研究提供了建议。<br>        In this survey we will explain the problem of change point detection and explore how different supervised and unsupervised methodologies can be used for detecting change points in time series data. We will compare and contrast investigated techniques based on their cost, limitations, and performance. Finally, we discuss the gaps in the research, summarize challenges that arise for change point applications, and provide suggestions for continuing investigation.</p>
<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>图1绘制了一个包含几个变化点的示例时间序列。数据说明了斯匹次卑尔根在1899–2010年期间的长期平均年温度趋势[16]。该数据可用于气候变化检测。该图突出表明了这一时期斯匹次卑尔根州的气候经历了六个不同的时期。我们将时间序列的这些部分称为时间序列的状态，即控制过程的参数不变的时间段。两个连续的不同状态通过更改点来区分。变更点检测的目的是通过发现变更点来识别这些状态边界。<br>        Figure 1 graphs an example time series that contains several change points. The data illustrate long term mean annual temperature trends of Spitsbergen for the period 1899–2010 [16]. The data can be used for climate change detection. This plot highlights the observation that the climate of Spitsbergen went through six different regimes in this period. We refer to these portions of the time series as states of the time series, or periods of time when the parameters governing the process do not change. Two consecutive distinct states are distinguished by a change point. The objective of change point detection is to identify these state borders by discovering the change points.</p>
<h3 id="定义和问题表述"><a href="#定义和问题表述" class="headerlink" title="定义和问题表述"></a>定义和问题表述</h3><p>Definitions and Problem Formulation</p>
<p>我们首先介绍整个调查中使用的关键术语的定义。<br>        We begin by presenting definitions of key terms that we use throughout this survey.</p>
<p>定义1：时间序列数据流是元素的无限序列<br>        Definition 1: A time series data stream is an infinite sequence of elements</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105339159.png" alt="image-20201127105339159"></p>
<p>其中xi是到达时间戳i [17]的d维数据向量。<br>        where $x_i$ is a d-dimensional data vector arriving at time stamp i [17].</p>
<p>定义2：固定时间序列是一个有限方差过程，其统计属性在时间上都是恒定的[18]。该定义假设<br>        Definition 2: A stationary time series is a finite variance process whose statistical properties are all constant over time [18]. This definition assumes that</p>
<p>平均值函数μt= E（xt）是常数，并且不依赖于时间t。 •自协方差函数γ（s，t）= cov（xs，xt）= E [（xs-μs）（xt-μt）]仅取决于时间戳s和t的时间差，或| s – t |。<br>        The mean value function μt = E(xt) is constant and does not depend on time t. • The auto covariance function γ(s, t) = cov(xs, xt) = E[(xs − μs)(xt − μt)] depends on time stamps s and t only through their time difference, or |s – t|.</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105423941.png" alt="image-20201127105423941"></p>
<p>定义3：独立且分布均匀的变量（i.i.d.）彼此相互独立，并且从它们从相同的概率分布中提取的意义上来说分布相同。 I.i.d.时间序列是固定时间序列的特例。<br>        Definition 3: Independent and identically distributed (i.i.d.) variables are mutually independent of each other, and are identically distributed in the sense that they are drawn from the same probability distribution. An i.i.d. time series is a special case of a stationary time series.</p>
<p>定义4：给定固定长度为m的时间序列T（时间序列数据流的子集），并且在时间t处将xt作为序列样本，则可以通过移动滑动窗口来构建长度为k的所有可能子序列的矩阵WM大小T跨T，并将子序列Xp = {xp，xp + 1，…，xp + k}（图2）放置在WM的第p行中。所得矩阵WM的大小为（m-k + 1）×n [19] [20]。<br>        Definition 4: Given a time series T of fixed length m (a subset of a time series data stream) and xt as a series sample at time t, a matrix WM of all possible subsequences of length k can be built by moving a sliding window of size k across T and placing subsequence Xp = {xp, xp+1, … , xp+k} (Figure 2) in the pth row of WM. The size of the resulting matrix WM is (m − k + 1) × n [19][20].</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105448566.png" alt="image-20201127105448566"></p>
<p>定义5：在一个时间序列中，使用滑动窗口Xt代替xt作为样本，具有汉克矩阵{Xt，Xt + 1，…，Xt + n–1}的间隔χt如图2所示。从时间t [2] [21] [22]开始的n个回顾性子序列样本。<br>        Definition 5: In a time series, using sliding window Xt as a sample instead of xt, an interval χt with Hankel matrix {Xt, Xt+1, … , Xt+n–1} as shown in Figure 2 will be a set of n retrospective subsequence samples starting at time t [2][21][22].</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105519512.png" alt="image-20201127105519512"></p>
<p>定义6：变化点表示生成时间序列数据的过程中不同状态之间的过渡。<br>        Definition 6: A change point represents a transition between different states in a process that generates the time series data.</p>
<p>定义7：设{xm，xm + 1，。 。 ，xn}是时间序列变量的序列。变更点检测（CPD）可以定义为两个备选方案之间的假设检验问题，原假设H0：“未发生变更”，备选假设HA：“发生变更” [23] [24]<br>        Definition 7: Let {xm, xm+1, . . , xn} be a sequence of time series variables. Change point detection (CPD) can be defined as the problem of hypothesis testing between two alternatives, the null hypothesis H0: “No change occurs” and the alternative hypothesis HA: “A change occurs” [23][24]</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105544860.png" alt="image-20201127105544860"></p>
<h3 id="标准-Criteria"><a href="#标准-Criteria" class="headerlink" title="标准 Criteria"></a>标准 Criteria</h3><p>在上一节中，我们提供了对传统变更点检测的正式介绍。但是，更改点检测的实际应用带来了许多新的挑战，需要解决。在这里，我们介绍并描述其中的一些挑战。<br>        In the previous section we provide a formal introduction to the traditional change point detection. However, practical application of change point detection introduces a number of new challenges that need to be addressed. Here we introduce and describe some of these challenges.</p>
<h4 id="2-2-1在线检测"><a href="#2-2-1在线检测" class="headerlink" title="2.2.1在线检测"></a>2.2.1在线检测</h4><p>变更点检测算法传统上分为“在线”或“离线”。脱机算法会立即考虑整个数据集，并及时回溯以识别更改发生的位置。该方案的目标通常是在批处理模式下识别序列的所有更改点。相反，在线或实时算法与它们正在监视的过程同时运行，在每个数据点可用时对其进行处理，目的是在发生变化后尽快（最好是在下一个数据之前）检测变化点。点到达[25]。<br>        2.2.1 Online detection—Change point detection algorithms are traditionally classified as “online” or “offline”. Offline algorithms consider the entire data set at once, and look back in time to recognize where the change occurred. The goal of this scenario is generally to identify all of a sequence’s change points in batch mode. In contrast, online, or real-time, algorithms run concurrently with the process they are monitoring, processing each data point as it becomes available, with a goal of detecting a change point as soon as possible after it occurs, ideally before the next data point arrives [25].</p>
<p>实际上，没有任何变更点检测算法能够完美实时地运行，因为它必须在确定新旧数据点之间是否发生变更点之前检查新数据。但是，不同的在线算法在发生变化点检测之前需要不同数量的新数据。基于此观察，我们将定义一个在本文中使用的新术语。我们将在线算法表示为ε–实时算法，该算法在新一批数据中至少需要ε数据样本才能找到变化点。离线算法可以看作是∞实时，而完全在线算法是1实时，因为对于每个数据点，它都可以预测在新数据点之前是否发生了变化。较小的ε值可能导致更强大，更响应的变化点检测算法。<br>        In practice, no change point detection algorithm operates in perfect real time because it must inspect new data before determining if a change point occurred between the old and new data points. However, different online algorithms require different amounts of new data before change point detection can occur. Based on this observation we will define a new term to use throughout this paper. We will denote as an ε –real time algorithm an online algorithm which needs at least ε data samples in the new batch of data to be able to find change points. An offline algorithm can then be viewed as ∞ –real time and the completelyonline algorithm is 1-real time because for every data point, it can predict whether or not a change point occurs before the new data point. Smaller ε values may lead to stronger, more responsive change point detection algorithms.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105700621.png" alt="image-20201127105700621"></p>
<h4 id="2-2-2可伸缩性"><a href="#2-2-2可伸缩性" class="headerlink" title="2.2.2可伸缩性"></a>2.2.2可伸缩性</h4><p>—来自人类活动和遥感卫星等来源的现实世界时间序列数据在数据点数量和维度数量上都变得越来越大。变更检测方法需要以计算有效的方式进行设计，以便可以扩展到海量数据[26]。因此，我们比较了替代CPD算法的计算成本，以确定哪种算法可以尽快达到最佳（或足够好的）解决方案。比较算法的计算成本的一种方法是找到算法是参数化还是非参数化。区分参数方法和非参数方法非常重要，因为非参数方法对于大型数据集已显示出更大的成功。同样，参数化方法的计算成本比非参数化方法更高，并且不能随数据集的大小而缩放[23]。<br>        2.2.2 Scalability—Real world time series data from sources such as human activities and remote sensing satellites are becoming ever larger in both number of data points and number of dimensions. Change detection methods need to be designed in a computationally efficient manner so that they can scale to massive data sizes [26]. Hence we compare the computational cost of alternative CPD algorithms to determine which one can reach an optimal (or a good enough) solution as fast as possible. One way to compare the computational cost of the algorithms is finding the algorithm is parametric or nonparametric. Distinguishing between parametric and nonparametric approaches is important because nonparametric approaches have demonstrated greater success for massively large datasets. Also, the computational cost of parametric methods is higher than nonparametric approaches and does not scale as well with the size of the dataset [23].</p>
<p>参数化方法指定了模型要学习的特定功能形式，然后基于标记的训练数据估计未知参数。一旦训练了模型，就可以丢弃训练示例。相反，非参数方法不对基础函数的形式做任何假设。要付出的相应代价是，在进行推论时必须保留所有可用数据[27]。<br>        A parametric approach specifies a particular functional form to be learned by the model and then estimates the unknown parameters based on labeled training data. Once the model has been trained the training examples can be discarded. In contrast, nonparametric methods do not make any assumptions about the form of the underlying function. The corresponding price to be paid is that all the available data has to be retained while making the inference [27].</p>
<p>成功的算法必须权衡决策质量与审议成本。一种有前途的方法是使用随时算法[28]，该算法允许在任何时间中断执行并输出迄今为止获得的最佳解决方案。一种类似的方法是一种合同算法，该算法也要权衡计算时间与解决方案质量之间的关系，但是预先将允许的运行时间作为合同协议的一种类型。与任何时候算法相比，合同算法接收其允许的执行时间作为指定参数。如果合同算法在分配的时间完成之前被中断，则可能不会产生任何有用的结果。可中断算法（例如随时算法）是一种其执行时间未事先给出的算法，因此必须随时准备被中断，但它会利用可用时间来不断提高其解决方案的质量。通常，每种可中断算法都是契约算法，但是反之则不成立[29]。<br>        A successful algorithm must trade off decision quality for deliberation cost. One promising approach is to use anytime algorithms [28] which allow the execution to be interrupted at any time and output the best possible solution obtained so far. A similar method is a contract algorithm which also trades off computation time for solution quality but is given the allowable run time in advance as a type of contract agreement. In contrast to an anytime algorithm, a contract algorithm receives its allowable execution time as a specified parameter. If a contract algorithm is interrupted before the allocated time is completed, it might not yield any useful results. An interruptible algorithm (such as an anytime algorithm) is one whose execution time is not given in advance and thus must be prepared to be interrupted at any moment, but it uses available time to continually improve the quality of its solution. In general, every interruptible algorithm is trivially a contract algorithm, but the converse is not true [29].</p>
<h4 id="2-2-3算法约束"><a href="#2-2-3算法约束" class="headerlink" title="2.2.3算法约束"></a>2.2.3算法约束</h4><p>也可以基于对输入数据和算法施加的要求来区分CPD的方法。这些约束对于选择适当的技术来检测特定数据序列中的变化点很重要。与时间序列数据的性质相关的约束可能来自平稳性[30]，即。 [31]，数据的维度或连续性[32]。<br>        2.2.3 Algorithm constraints—Approaches to CPD can also be distinguished based on the requirements that are imposed on the input data and the algorithm. These constraints are important in selecting an appropriate technique for detecting change points in a specific data sequence. Constraints related to the nature of the time series data may emanate from the stationarity [30], i.i.d. [31], dimensionality, or continuity of the data [32].</p>
<p>一些算法需要有关数据的信息，例如数据中的变更点数，系统中的状态数以及系统状态的特征[33] [34]。参数方法中的另一个重要问题是算法对初始参数值选择的敏感程度。<br>        Some of the algorithms require information about the data, such as the number of change points in the data, the number of states in the system, and the features of the system states [33][34]. Another important issue in parametric methods is the degree to which the algorithm is sensitive to the choice of initial parameter values.</p>
<h3 id="2-3绩效评估"><a href="#2-3绩效评估" class="headerlink" title="2.3绩效评估"></a>2.3绩效评估</h3><p>​        2.3 Performance Evaluation</p>
<p>为了比较替代的CPD算法并估计预期的结果性能，需要对性能进行度量。引入了许多性能指标来根据变更点检测算法做出的决策类型对其进行评估[35]。 CPD算法的输出可以包含以下内容：<br>        In order to compare alternative CPD algorithms and estimate the expected resulting performance, measures of performance are needed. Many performance metrics have been introduced to evaluate change point detection algorithms based on the type of decisions they make [35]. The output of CPD algorithms can contain the following:</p>
<p>​    更改点是/否决策（算法是二进制分类器）</p>
<p>•具有不同精度级别的更改点识别（即=更改点出现在x个时间单位内。这种类型的算法利用多分类器或无监督学习方法</p>
<p>•下一个变更点的时间（或系列中所有变更点的时间）<br>        Change-point yes/no decisions (the algorithm is a binary classifier) • Change point identification with varying levels of precision (i.e., the =change point occurs within x time units. This type of algorithm utilizes a multi-class classifier or unsupervised learning methods. • The time of the next change point (or the times of all change points in the series)</p>
<p>在前两种输出的情况下，可以使用评估监督学习算法的标准方法来评估变化点检测器的性能。评估有监督的变更点学习者的表现的第一步是生成一个混淆矩阵，该矩阵总结了实际和预测的类别。表1示出了用于二进制变化点分类器的混淆矩阵。<br>        In case of the first two types of output, standard methods for evaluating supervised learning algorithms can be utilized to evaluate the performance of the change point detector. A first step at evaluating the performance of a supervised change point learner is to generate a confusion matrix which summarizes the actual and predicted classes. Table 1 illustrates a confusion matrix for a binary change point classifier.</p>
<p>下面总结了一些可用于评估CPD算法的有用性能指标。虽然这些描述是在二进制分类的上下文中进行的，但它们可以通过独立地或组合地为每个类别提供度量来扩展到更多类别的分类。<br>        Some of the useful performance metrics that we can employ to evaluate CPD algorithms are summarized below. While these are described in the context of binary classification, they can each be extended to classification of a greater number of classes by providing the measures for each class independently or in combination.</p>
<p>准确性，计算为正确分类的数据点与总数据点的比率。这项措施提供了有关算法性能的高级思路。准确性的陪伴者是错误率，它的计算公式为1-准确性。准确性和错误率不能提供有关错误来源或不同类别之间错误分布的见解。此外，它们对于评估类不平衡数据集中的性能无效，这对于更改点检测很典型，因为它们认为不同类型的分类错误同等重要。在这种情况下，灵敏度和g均值是有用的指标。<br>        Accuracy, calculated as the ratio of correctly-classified data points to total data points. This measure provides a high-level idea about the algorithm’s performance. The companion to accuracy is Error Rate, which is computed as 1 - Accuracy. Accuracy and Error Rate do not provide insights on the source of the error or the distribution of error among the different classes. In addition, they are ineffective for evaluating performance in a class-imbalanced dataset, which is typical for change point detection, because they consider different types of classification errors as equally important. Sensitivity and g-mean are useful metrics to utilize in this case.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105944464.png" alt="image-20201127105944464"></p>
<p>灵敏度，也称为召回率或真实阳性率（TP率）。这指的是正确识别的兴趣类别（更改点）的一部分。<br>        Sensitivity, also referred to as Recall or the true positive rate (TP Rate). This refers to the portion of a class of interest (Change Points) that was recognized correctly.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127105959203.png" alt="image-20201127105959203"></p>
<p>G均值。变更点检测通常会导致班级分布不均衡的学习问题，因为变更与总数据的比率很小。因此，G均值通常用作CPD绩效的指标。这利用敏感性和特异性度量来评估算法的性能，包括正准确率（Sensitivity）和负准确率（Specificity）之比。<br>        G-mean. Change point detection typically results in a learning problem with an imbalanced class distribution because the ratio of changes to total data is small. As a result, G-mean is commonly used as an indicator of CPD performance. This utilizes both Sensitivity and Specificity measures to assess the performance of the algorithm both in terms of the ratio of positive accuracy (Sensitivity) and the ratio of negative accuracy (Specificity).<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110012038.png" alt="image-20201127110012038"></p>
<p>精确。这是根据真实阳性数据点（更改点）与归类为更改点的总点数之比计算得出的。<br>        Precision. This is calculated as the ratio of true positive data points (change points) to total points classified as change points.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110032051.png" alt="image-20201127110032051"></p>
<p>F度量（也称为f分数或f1分数）。该措施提供了一种将“精确度”和“召回率”相结合的方法，以衡量CPD算法的整体有效性。 F度量计算为“精确度”和“召回率”的加权重要性的比率。<br>        F-measure (also referred to as f-score or f1 score). This measure provides a way to combine Precision and Recall as a measure of the overall effectiveness of a CPD algorithm. F-measure is calculated as a ratio of the weighted importance of Precision and Recall.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110043407.png" alt="image-20201127110043407"></p>
<p>接收器工作特性曲线（ROC）。基于ROC的评估有助于显式分析真阳性率和假阳性率之间的折衷。这是通过在x轴上绘制假阳性率而在y轴上绘制真实阳性率的二维图形来完成的。 CPD算法会生成一个（TP_Rate，FP_Rate）对，该对与ROC空间中的单个点相对应。如果一种算法的点比另一种算法更靠近（0,1）坐标（左上角），通常可以认为它优于另一种算法。要评估算法的整体性能，我们可以查看ROC曲线下的面积或AUC。总的来说，我们希望误报率要低，而真阳性率要高。这意味着AUC值越接近1，算法就越强大。可以从ROC曲线得出的另一个有用的度量是等错误率（EER），即误报率和误报率相等的点。通过强大的算法，这一点保持很小。<br>        Receiver Operating Characteristics Curve (ROC). ROC-based assessment facilitates explicit analysis of the tradeoff between true positive and false positive rates. This is done by plotting a two-dimensional graph with the false positive rate on the x axis and the true positive rates on the y axis. A CPD algorithm produces a (TP_Rate, FP_Rate) pair that corresponds to a single point in the ROC space. One algorithm can generally be considered as superior to another if its point is closer to the (0,1) coordinate (the upper left corner) than the other. To assess the overall performance of an algorithm, we can look at the Area Under the ROC curve, or AUC. In general, we want the false positive rate to be low and the true positive rate to be high. This means that the closer to 1 the AUC value is, the stronger is the algorithm. Another useful measure that can be derived from the ROC curve is the Equal Error Rate (EER), which is the point where the false positive rate and the false negative rate are equal. This point is kept small by a strong algorithm.</p>
<p>精确调用曲线（PR曲线）。也可以生成PRC，并将其用于比较其他CPD算法。 PR曲线将准确率作为召回率的函数。尽管ROC曲线的最佳算法性能由该空间左上角的点指示，但PR空间中的最佳性能接近右上角。与ROC一样，可以计算PRC下的面积以比较两种算法并尝试优化CPD性能。当班级分布严重偏斜时，PR曲线尤其可提供有见地的分析。<br>        Precision-Recall Curve (PR Curve). A PRC can also be generated and used to compare alternative CPD algorithms. The PR curve plots precision rate as a function of recall rate. While optimal algorithm performance for an ROC curve is indicated by points in the upper left of the space, optimal performance in the PR space is near the upper right. As with the ROC, the area under a PRC can be computed to compare two algorithms and attempt to optimize CPD performance. The PR curve in particular provides insightful analysis when the class distribution is highly skewed.</p>
<hr>
<p>如果检测到的更改点（CP）与实际CP之间的时间差表示性能的度量标准（使用监督或无监督的CPD方法），则上述度量标准不是适当的选择。评估这些算法的性能并不像前面的情况那样简单，因为没有单一的标签可用来衡量算法的性能。但是，对于这种情况，存在许多有用的指标，包括：<br>        If the difference in time between the detected change point (CP) and the actual CP represents the measure of performance (utilizing supervised or unsupervised CPD methods), then the above metrics are not appropriate choices. Evaluating the performance of these algorithms is not as straightforward as for the previous case, because there is no single label against which the performance of the algorithm can be measured. However, a number of useful metrics exist for this case, including:</p>
<p>平均绝对误差（MAE）。这直接测量了预测CP与实际CP的接近程度。在每个CP点上，将预测CP时间与实际CP时间之差的绝对值相加并归一化。<br>        Mean absolute error (MAE). This directly measures how close the predicted CP is to the actual CP . The absolute value of the difference between the predicted and actual CP time is summed and normalized over each of the CP points.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110143056.png" alt="image-20201127110143056"></p>
<p>均方误差（MSE）是MAE的众所周知的替代方法。在这种情况下，由于误差是平方的，所以如果分类数据中存在一些明显的异常值，则得出的度量将非常大。<br>        Mean squared error (MSE) is a well-known alternative to MAE. In this case, because the errors are squared, the resulting measure will be very large if a few dramatic outliers exist in the classified data.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110157165.png" alt="image-20201127110157165"></p>
<p>平均符号差（MSD）。除了计算预测CP和实际CP之间的差异外，此度量还考虑错误的方向（在实际CP时间之前或之后进行预测）。<br>        Mean signed difference (MSD). In addition to calculating the difference between the predicted and actual CP , this measure considers the direction of the error (predicting before or after the actual CP time).<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110208903.png" alt="image-20201127110208903"></p>
<p>均方根误差（RMSE）。这将汇总预测误差与实际误差之间的差异，并对每个差异进行平方以消除符号因子。计算最终估计值的平方根，以抵消对各个差异进行平方的比例因子。<br>        Root mean squared error (RMSE). This aggregates the difference between predicted and actual error and squares each difference to remove the sign factor. The square root is computed of the final estimate to offset the scaling factor of squaring the individual differences.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110221119.png" alt="image-20201127110221119"></p>
<p>归一化均方根误差（NRMSE）。该措施消除了值对预测值的单位大小的敏感性。 NRMSE有助于更直接地比较不同数据集之间的误差，并有助于解释误差度量。两种常见的方法是将误差归一化为观察到的CP的范围或归一化为观察到的CP的平均值。<br>        Normalized root mean squared error (NRMSE). This measure removes the sensitivity of the values to the unit size of the predicted value. NRMSE facilitates more direct comparison of error between different datasets and aids in interpreting the error measures. Two common methods are to normalize the error to the range of the observed CPs or normalize to the mean of the observed CPs.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110235567.png" alt="image-20201127110235567"></p>
<h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>已经设计，增强了许多机器学习算法，并将这些算法用于变化点检测。在这里，我们概述了通常用于CPD问题的基本算法。这些技术包括监督方法和非监督方法，它们是根据算法的期望结果选择的。<br>        Many machine learning algorithms have been designed, enhanced, and adapted for change point detection. Here, we provide an overview of the basic algorithms that are commonly applied to the CPD problem. These techniques include both supervised and unsupervised methods, chosen based on the desired outcome of the algorithm.</p>
<h3 id="监督方法"><a href="#监督方法" class="headerlink" title="监督方法"></a>监督方法</h3><p>Supervised Methods</p>
<p>监督学习算法是机器学习算法，用于学习从输入数据到数据目标属性的映射，该属性通常是类标签[35]。图3概述了变更点检测中使用的监督方法。当采用监督方法进行变更点检测时，机器学习算法可以训练为二进制或多类分类器。如果指定了状态数，则训练变更点检测算法以找到每个状态边界。滑动窗口在数据中移动，将两个数据点之间的每个可能划分视为一个可能的变化点。尽管此方法的培训阶段更简单，但是需要提供足够数量和多样性的培训数据来代表所有课程。另一方面，分别检测每个类别可提供足够的信息以找到检测到的变化的性质和数量。各种分类器可用于此学习问题。例子包括决策树[33] [34] [36] [37]，朴素贝叶斯[33]，贝叶斯网[34]，支持向量机[33] [34]，最近邻[33] [20]，隐马尔可夫模型[38] [39] [33]，条件随机字段[34]和高斯混合模型（GMM）[38] [39]。<br>        Supervised learning algorithms are machine learning algorithms that learn a mapping from input data to a target attribute of the data, which is usually a class label [35]. Figure 3 provides an overview of supervised methods used in change point detection. When a supervised approach is employed for change point detection, machine learning algorithms can be trained as binary or multi-class classifiers. If the number of states is specified, the change point detection algorithm is trained to find each state boundary. A sliding window moves through the data, considering each possible division between two data points as a possible change point. While this approach has a simpler training phase, a sufficient amount and diversity of training data needs to be provided to represent all of the classes. On the other hand, detecting each class separately provides enough information to find both the nature and the amount of detected change. A variety of classifiers can be used for this learning problem. Examples include decision tree [33][34][36][37], naïve Bayes [33], Bayesian net [34], support vector machine [33][34], nearest neighbor [33][20], hidden Markov model [38][39][33], conditional random field [34], and Gaussian mixture model (GMM) [38][39].</p>
<p>一种替代方法是将更改点检测视为二进制类别问题，其中所有可能的状态转换（更改点）序列代表一个类别，而所有内部状态序列则代表第二个类别。虽然在这种情况下只需要学习两个班级，但是如果可能的过渡类型数量很多，这将是一个更为复杂的学习问题[35]。与以前的监督方法类型一样，在这种学习方法中，输入向量中的每个特征都表示可能发生变化的来源。因此，任何生成可解释模型的监督学习算法（例如决策树或规则学习器）都不仅会识别更改，而且还会描述更改的性质。支持向量机[21] [40]，朴素贝叶斯[21]和逻辑回归[21]已经使用这种方法进行了测试。这种类型的问题还将遭受极端的类别失衡，因为状态内序列通常比变化点序列多得多。<br>        An alternative is to treat change point detection as a binary class problem, where all of the possible state transition (change point) sequences represents one class and all of the withinstate sequences represents a second class. While only two classes need to be learned in this case, this is a much more complex learning problem if the number of possible types of transitions is large [35]. As with the previous type of supervised approaches, in this learning approach each feature in the input vector indicates a source of possible change. Therefore, any supervised learning algorithm that generates an interpretable model (such as a decision tree or a rule learner) will not only identify a change but also describe the nature of the change. Support vector machines [21][40], naïve Bayes [21], and logistic regression [21] have been tested using this approach. This type of problem will also suffer from extreme class imbalance as there are typically many more within-state sequences than change point sequences.</p>
<p>另一种受监督的方法是使用虚拟分类器[4]。这种方法不仅可以检测更改，还可以实际解释两个连续窗口之间发生的更改。虚拟分类器在第一个窗口的每个样本上附加一个假设标签（+1），在第二个窗口对每个样本附加（-1）个假设标签，然后使用任何监督方法基于标记的数据点训练虚拟分类器（VC）。如果两个窗口之间存在变化点，则应该由分类器正确分类，并且分类精度p应该明显高于随机噪声prand = 0.5。为了测试变化得分的显着性，使用二项式分布的逆生存函数来确定临界值pcritical，在该临界值下，伯努利试验有望超过带有α置信度的prand。最后，如果p&gt; pcritical，则两个窗口之间存在显着变化。一旦检测到变化点，就使用两个相邻窗口中的所有样本对分类器进行重新训练。如果某些功能在分类器中起主导作用，那么它们就是表征差异的特征。<br>        Another supervised approach is to use a virtual classifier [4]. This method goes beyond just detecting changes to actually interpreting a change that occurs between two consecutive windows. The virtual classifier attaches a hypothetical label (+1) to each sample from the first window and (−1) to each sample from the second window, then trains a virtual classifier (VC) using any supervised method based on the labeled data points. If there is a change point between two windows, they should be correctly classified by the classifier and the classification accuracy p should be significantly higher than random noise prand=0.5. In order to test the significance of a change score, the inverse survival function of a binomial distribution is used to determine a critical value, pcritical, at which Bernoulli trials are expected to exceed prand with α confidence level. Finally, if p &gt; pcritical, a significant change exists between the two windows. Once the change point is detected, the classifier is retrained using all of the samples in the two neighboring windows. If some features play a dominant role in the classifier, then they are the ones that characterize the difference.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110349691.png" alt="image-20201127110349691"></p>
<h3 id="无监督方法-Unsupervised-Methods"><a href="#无监督方法-Unsupervised-Methods" class="headerlink" title="无监督方法 Unsupervised Methods"></a>无监督方法 Unsupervised Methods</h3><p>无监督学习算法通常用于发现未标记数据中的模式。在变化点检测的上下文中，此类算法可用于分割时间序列数据，从而根据数据的统计特征查找变化点。无监督分割很有吸引力，因为它可以处理各种不同的情况，而无需对每种情况进行事先培训。图4概述了用于变更点检测的无监督方法。早期报道的方法基于两个连续区间的概率密度相同（如果它们属于同一状态）的观察结果，利用似然比。另一个传统的解决方案是子空间建模，它表示使用状态空间的时间序列，从而通过预测状态空间参数来检测变化点。概率方法基于自上一个候选更改点以来已观察到的数据来估计新间隔的概率分布。相反，基于核的方法将观察结果映射到高维特征空间，并通过比较每个子序列的同质性来检测变化点。基于图的技术是一种新引入的方法，该方法将时间序列观察结果表示为图，并基于此表示应用统计测试来检测变化点。最后，聚类方法将时间序列数据分为各自的状态，并通过识别状态特征之间的差异来查找更改。<br>        Unsupervised learning algorithms are typically used to discover patterns in unlabeled data. In the context of change point detection, such algorithms can be used to segment time series data, thus finding change points based on statistical features of the data. Unsupervised segmentation is attractive because it may handle a variety of different situations without requiring prior training for each situation. Figure 4 provides an overview of unsupervised methods that have been used for change point detection. Early reported methods utilize likelihood ratio based on the observation that the probability density of two consecutive intervals are the same if they belong to the same state. Another traditional solution is subspace modelling, which represents a time series using state spaces and thus detects change points by predicting the state space parameters. Probabilistic methods estimate probability distributions of the new interval based on the data that has been observed since the previous candidate change point. In contrast, kernel-based methods map observations onto a higher-dimensional feature space and detect change points by comparing the homogeneity of each subsequence. The graph based technique is a newly-introduced method which represents time series observations as a graph and applies statistical tests to detect change points based on this representation. Finally, clustering methods group time series data into their respective states and find changes by identifying differences between features of the states.</p>
<p>似然比方法-变更点检测的一种典型统计公式是分析候选变更点之前和之后的数据概率分布，如果两种分布明显不同，则将候选者识别为变更点。在这些方法中，监视时序数据中两个连续间隔之间的似然比的对数，以检测变化点[2]。<br>        Likelihood Ratio Methods—A typical statistical formulation of change-point detection is to analyze the probability distributions of data before and after a candidate change point, and identify the candidate as a change point if the two distributions are significantly different. In these approaches, the logarithm of the likelihood ratio between two consecutive intervals in time-series data is monitored for detecting change points [2].</p>
<p>此策略需要两个步骤。首先，分别计算两个连续间隔的概率密度。其次，计算这些概率密度的比率。最熟悉的变化点算法是累积总和[41] [42] [43] [44]，它累积相对于传入测量的指定目标的偏差，并在累积总和超过指定阈值时指示存在变化点。<br>        This strategy requires two steps. First, the probability density of two consecutive intervals is calculated separately. Second, the ratio of these probability densities is computed. The most familiar change point algorithm is cumulative sum [41][42][43][44], which accumulates deviations relative to a specified target of incoming measurements and indicates that a change point exists when the cumulative sum exceeds a specified threshold.</p>
<p>更改查找器[2] [45] [22]是另一种常用的方法，它将更改点检测的问题减少为基于时间序列的离群值检测。该方法将自动回归（AR）模型拟合到数据上以表示时间序列的统计行为，并逐步更新其参数估计值，从而逐渐消除了过去示例的影响。考虑时间序列xt，我们可以使用第k次的AR模式对时间序列建模:<br>        Change Finder [2][45][22] is another commonly used method which reduces the problem of change point detection into time series-based outlier detection. This method fits an Auto Regression (AR) model onto the data to represent the statistical behavior of the time series and updates its parameter estimates incrementally so that the effect of past examples is gradually discounted. Considering time series xt, we can model the time series using an AR mode of the kth order by</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110502818.png" alt="image-20201127110502818"></p>
<p>哪里有以前的观测值，ω=（ω1，…，ωk）∈ℝk是常数，ε是根据高斯分布（如白噪声）生成的正态随机变量。通过更新模型参数，可以计算出时间t处的概率密度函数，并得到一系列概率密度{pt：t = 1，2，…}。接下来，通过给每个数据点计分来生成辅助时间序列yt。该得分函数定义为对数似然的平均值，Score（yt）= − log pt–1（yt），或统计偏差，Score（yt）= d（pt-1，pt），其中d（* ，<em>）由许多距离函数中的任何一个提供，包括变化距离，赫林格距离或二次距离。新的时间序列数据表示每对连续时间序列间隔之间的差异。为了检测变化点，我们需要知道两个连续差异之间是否存在突变。为此，将另一个AR模型拟合到基于差异的时间序列，并构建新的概率密度函数序列{qt：t = 1，2，…}。使用前述得分函数定义改变点得分。分数越高表示成为更改点的可能性越高。<br>        where are previous observations, ω = (ω1, … , ωk) ∈ ℝk are constants, and ε is a normal random variable generated according to a Gaussian distribution like white noise. By updating model parameters the probability density function at time t is calculated and we have a sequence of probability densities {pt: t = 1, 2, … }. Next, an auxiliary time-series yt is generated by giving a score to each data point. This score function is defined as the average of the log-likelihood, Score(yt) = − log pt–1(yt), or statistical deviation, Score(yt) = d(pt–1, pt), where d(</em>,*) is provided by any of a number of distance functions including variation distance, Hellinger distance, or quadratic distance. The new time series data represents the difference between each pair of consecutive time series intervals. In order to detect change points, we need to know if there are abrupt changes between two consecutive differences. To do this, one more AR model is fit to the differencebased time series and a new sequence of probability density functions {qt: t = 1, 2, … } is constructed. The change-point score is defined using aforementioned score function. A higher score indicates a higher possibility of being a change point.</p>
<p>由于这些方法依赖于预先设计的参数模型，并且在现实世界中的变化点检测方案中灵活性较差，因此一些最新研究通过直接估算概率密度的比率而引入了更为灵活的非参数变化，而无需执行密度估算。这种密度比估计思想的基本原理是，知道两个密度意味着知道密度比。但是，反之则不成立：知道这种比率并不一定意味着知道这两种密度，因为这种分解不是唯一的。因此，直接密度比估计实质上比密度估计简单。遵循这个想法，已经开发出直接密度比估计的方法[2] [22]。这些方法通过非参数高斯核模型对两个结果区间χ和χ’之间的密度比进行建模，如下所示：<br>        Since these methods rely on pre-designed parametric models and they are less flexible in real-world change point detection scenarios, some recent studies introduce more flexible non-parametric variations by estimating the ratio of probability densities directly without needing to perform density estimation. The rationale of this density-ratio estimation idea is that knowing the two densities implies knowing the density ratio. However, the inverse is not true: knowing the ratio does not necessarily imply knowing the two densities because such decomposition is not unique. Thus, direct density-ratio estimation is substantially simpler than density estimation. Following this idea, methods of direct density-ratio estimation have been developed [2][22]. These methods model the density ratio between two consequent intervals χ and χ′ by a non-parametric Gaussian kernel model as follows:</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110524783.png" alt="image-20201127110524783"></p>
<p>其中p（χ）是区间χ的概率分布，θ=（θ1，…，θn）T是要从数据样本中学习的参数，X是滑动窗口，而σ&gt; 0是核参数。在训练阶段，确定参数θ，以使差异度最小。给定密度比估计值g（χ），在测试阶段计算两个样本χt和χt+ n之间的不相似性度量的近似值。相异性度量越高，该点就越有可能是变化点[2] [22]。<br>        Where p(χ) is the probability distribution of interval χ, θ = (θ1, … , θn)T are parameters to be learned from data samples, X is a sliding window, and σ &gt; 0 is the kernel parameter. In the training phase, the parameters θ are determined so that the dissimilarity measure is minimized. Given a density-ratio estimator g(χ), an approximator of the dissimilarity measure between two samples χt and χt+n is calculated in the test phase. The higher the dissimilarity measure is, the more likely the point is a change point [2][22].</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110544262.png" alt="image-20201127110544262"></p>
<p>差异度量的一个流行选择是Kullback-Leibler（KL）散度：<br>        A popular choice for the dissimilarity measure is Kullback-Leibler (KL) divergence:</p>
<p>Kullback-Leibler重要性估计程序（KLIEP）使用KL散度估计密度比。该问题是凸优化问题，因此可以例如通过梯度投影法简单地获得唯一的全局最优解θ。投影的梯度下降在每一步都朝负梯度的方向移动，并投影到可行的参数上。 KL发散的近似结果由以下公式[2] [22]给出。<br>        The Kullback-Leibler importance estimation procedure (KLIEP) estimates the density ratio using KL divergence. This problem is a convex optimization problem, so the unique global optimal solution θ can be simply obtained, for example, by a gradient projection method. Projected gradient descent moves in the direction of the negative gradient at each step and projects onto the feasible parameter. The resulting approximation of KL divergence is given in the following equation [2][22].<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110649144.png" alt="image-20201127110649144"></p>
<p>另一个直接密度比估计器是uLSIF（无约束最小二乘重要性拟合），其使用Pearson（PE）发散作为相异性度量，如下所示：<br>        Another direct density ratio estimator is uLSIF (Unconstrained Least-Squares Importance Fitting) which uses Pearson (PE) divergence as a dissimilarity measure, shown as:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110701601.png" alt="image-20201127110701601"></p>
<p>作为uLSIF训练准则的一部分，在平方损失下将密度比模型拟合为真实的密度比。 PE散度的近似值如下[22]：<br>        As part of the uLSIF training criterion, the density-ratio model is fitted to the true density ratio under the squared loss. An approximator of the PE divergence is as follows [22]:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110711874.png" alt="image-20201127110711874"></p>
<p>取决于第二间隔密度p’（x）的条件，密度比值可以是无界的。为了克服这个问题，在称为相对uLSIF（RuLSIF）的方法中，将0≤α&lt;1的α相对PE散度用作相异性度量。 RuLSIF措施是：<br>        Depending on the condition of the second interval density p′ (x), the density-ratio value can be unbounded. To overcome this problem, α -relative PE divergence for 0 ≤ α &lt; 1 is used as a dissimilarity measure in an approach known as Relative uLSIF (RuLSIF). The RuLSIF measure is:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110726172.png" alt="image-20201127110726172"></p>
<p>如果α= 0，则α相对密度比将减小为普通密度比，并且随着α增大，它趋于“平滑”。 RuLSIF的新颖之处在于它总是被包围，并且已经显示出用于估计相对密度比的收敛速度比uLSIF的收敛速度要快[22] [46]。<br>        The α-relative density ratio is reduced to a plain density ratio if α = 0, and it tends to be “smoother” as α gets larger. The novelty of RuLSIF is that it is always bounded above by , and it has been shown that the convergence rate for estimating the relative density ratio is faster than that of the uLSIF [22][46].</p>
<p>最近，半参数对数似然变化检测器（SPLL）[47] [48] [49]被提出作为基于Kullback-Leibler统计数据的半参数变化检测器。假设更改点（窗口W1）之前的数据来自高斯混合p1（x）。使用第二个窗口中数据的对数似然性的上限W2使用x和其中心之间的最小Mahalanobis距离平方的分量的索引来得出更改检测标准。如果W2不是来自W1的相同分布，则距离的平均值将偏离n（其中n是特征空间的维数）。大于或小于指定范围的SPLL值将指示更改。重要的是要注意，所有这些估计方法的准确性都会因数据噪声而降低[46]。<br>        Recently, a Semi-Parametric Log-Likelihood Change Detector (SPLL) [47][48][49] was proposed as a semi-parametric change detector based on Kullback-Leibler statistics. Suppose that the data before the change point (window W1) come from a Gaussian mixture, p1(x). The change detection criterion is derived using an upper bound of the log-likelihood of the data in the second window, W2 using the index of the component with the smallest squared Mahalanobis distance between x and its center. If W2 does not come from the same distribution of W1, then the mean of the distances will deviate from n (where n is the dimensionality of the feature space). A value of SPLL that is larger or smaller than a specified range will indicate a change. It is important to note that the accuracy of all of these estimation methods is degraded by data noise [46].</p>
<p>子空间模型方法<br>        Subspace Model Methods</p>
<p>另一研究领域是基于对时间序列受约束的子空间的分析来进行变化点检测。这种方法与系统识别方法密切相关，系统识别方法已在控制理论领域进行了深入研究[2]。<br>        Another line of research bases change point detection on an analysis of subspaces in which time series sequences are constrained. This approach has a strong connection with a system identification method, which has been thoroughly studied in the area of control theory [2].</p>
<p>一种这样的子空间模型方法称为子空间识别（SI）[22] [50]。 SI基于系统的状态空间模型，该模型也明确考虑了噪声因素。<br>        One such subspace model method is called subspace identification (SI) [22][50]. SI is based on a state space model of the system which also explicitly considers a noise factor.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110806125.png" alt="image-20201127110806125"></p>
<p>这里的C和A是系统矩阵，e（t）表示系统噪声，K是固定的卡尔曼增益。我们在子空间方法中使用了不同的符号。由于在这些方法中x代表模型状态，因此我们将y用作时间序列。<br>        Here C and A are system matrices, e(t) represents system noise and K is the stationary Kalman gain. We are using different notation in subspace methods. Since in these methods x represents model states, we use y as time series.</p>
<p>在系统识别中，扩展的可观察性矩阵是衡量通过其外部输出（y（t））可以推断出系统内部状态（x（t））的程度的度量。在这里，我们使用扩展的可观察性矩阵作为时间空间数据受约束的子空间的表示。<br>        In system identification, an extended observability matrix is a measure for how well internal states (x(t)) of a system can be inferred by knowledge of its external outputs, (y(t)). Here we use the extended observability matrix as a representation of a subspace in which time series data are constrained.</p>
<p>扩展的可观察性矩阵定义为：<br>        An extended observability matrix is defined as:</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110835207.png" alt="image-20201127110835207"></p>
<p>对于第2.1节中所述的每个间隔，SI使用标准化条件协方差的LQ分解和奇异值分解（SVD）估计可观察性矩阵。 LQ分解是将矩阵正交分解为较低梯形矩阵。矩阵A的SVD是将A分解为三个矩阵A = UDVT的乘积，其中U和V的列是正交的，矩阵D是对角的，且具有正实项。在下一步中，计算子空间之间的间隙并将其用作时间序列顺序变化的度量。可以将这种变化量度D与指定的阈值进行比较，以确定当前点是否为变化点。<br>        For each interval as described in Section 2.1, SI estimates the observability matrix using LQ factorization and Singular V alue Decomposition (SVD) of the normalized conditional covariance. LQ factorization is the orthogonal decomposition of a matrix into lower trapezoidal matrices. The SVD of a matrix A is the factorization of A into the product of three matrices A = UDVT where the columns of U and V are orthonormal and the matrix D is diagonal with positive real entries. In the next step, the gap between subspaces is calculated and utilized as a measure of the change in the time series sequence. This measure of change, D, can be compared to a specified threshold to determine if the current point is a change point.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110853991.png" alt="image-20201127110853991"></p>
<p>在此，χ表示新间隔的汉克尔矩阵，U是由先前间隔的估计扩展可观察性矩阵的SVD计算得出的。<br>        Here χ represents the Hankel matrix of the new interval and U is calculated by the SVD of the estimated extended observability matrix for the previous interval.</p>
<p>我们将讨论的下一个子空间模型方法称为奇异频谱变换（SST）[11] [22] [30]，它也是基于状态空间模型。但是，与SI模型不同，它不考虑系统噪声。 SST将基于解释的汉克矩阵为每个窗口定义一个轨迹矩阵，如以下等式所示：<br>        The next subspace model method we will discuss is called a Singular Spectrum Transformation (SST) [11][22] [30], which is also based on a state space model. Unlike the SI model, however, it does not consider the system noise. SST will define a trajectory matrix based on an explained Hankel matrix for each window as shown in the following equation:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110912953.png" alt="image-20201127110912953"></p>
<p>其中L是窗口长度，K是窗口数。可以使用SVD将轨迹矩阵分解为子矩阵。这些子矩阵由奇异值经验正交函数或EOF函数和主成分组成。基于距离的变化点分数是通过在连续间隔的两个轨迹矩阵的奇异谱之间进行比较来定义的。<br>        where L is the window length and K is the number of windows. The trajectory matrix can be decomposed into submatrices using SVD. These submatrices consist of singular value empirical orthogonal functions, or EOF functions, and principal components. Distancebased change point scores are defined by a comparison between singular spectrums of two trajectory matrices for consecutive intervals.</p>
<p>尽管这两种子空间模型方法都基于预定义的模型，但是SST并未考虑噪声对系统的影响。结果，它比SI对参数值的选择更敏感，并且对某些数据集显示出较低的准确性[22] [50]。<br>        Although both of these subspace model methods are based on a predefined model, SST does not consider the effect of noise on the system. As a result, it is more sensitive than SI to choices of parameter values and has demonstrated lower accuracies for some datasets [22] [50].</p>
<p>3.2.3概率方法-早期的贝叶斯变化点检测方法是离线的（∞–实时），并且基于追溯分段[51] [52]。在线贝叶斯变化点检测（BCPD）的第一种方法是在假设观察序列可以分为非重叠状态分区且时间序列中每个状态ρ的数据为i.d的前提下引入的。从某些概率分布P（xt |ηρ）[31]。<br>        3.2.3 Probabilistic Methods—Early Bayesian approaches to change point detection were offline ( ∞ – real time) and were based on retrospective segmentation [51][52]. One of the first approaches to online Bayesian change point detection (BCPD) was introduced under the assumption that a sequence of observations may be divided into non-overlapping states partitions and the data within each state ρ in time series are i.i.d. from some probability distribution P(xt|ηρ) [31].<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127110956786.png" alt="image-20201127110956786"></p>
<p>与仅考虑成对连续样本的先前方法相比，BCPD将新的滑动窗口特征与基于相同状态的所有先前间隔的估计值进行比较。 BCPD通过定义一个辅助变量游程长度（rt）来估计后验分布，该游程长度（rt）代表自上一个变化点以来经过的时间。给定时刻t的行程长度，下一个时间点的行程长度可以重置为0（如果此时发生变化点）或增加1（如果当前状态继续一个时间单位） 。基于贝叶斯定理的游程长度分布可以表示为：<br>        Compared to the previous methods which only consider pairs of consecutive samples, BCPD compares new sliding window features with the estimation based on all previous intervals from the same state. BCPD estimates the posterior distribution by defining an auxiliary variable run-length (rt) which represents the time that elapsed since the last change point. Given the run length at a time instant t, the run length at the next time point can either reset back to 0 (if a change point occurs at this time) or increase by 1 (if the current state continues for one more time unit). The run length distribution based on Bayes’ theorem can be denoted as:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111027586.png" alt="image-20201127111027586"></p>
<p>其中表示与运行时间rt相关的一组观察值，并且P（rt | rt-1），和P（rt-1，x1：t-1）是方程的先验，似然和递归分量。条件先验只有两个结果（rt = 0或rt = rt-1 + 1）为非零，从而简化了等式。<br>        Where indicates the set of observations associated with the run rt and P(rt|rt–1), , and P(rt–1, x1:t–1) are prior, likelihood, and recursive components of the equation. The conditional prior is nonzero at only two outcomes (rt = 0 or rt = rt–1 + 1) and simplifies the equation.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111041325.png" alt="image-20201127111041325"></p>
<p>在这个方程中，是一个危险函数，定义为运行中的概率密度与概率密度的总值之比[31] [53] [54]。可能性项表示最新数据属于当前行程的概率。这是计算中最具挑战性的术语，使用共轭指数模型时，它往往在计算上最有效[31]。<br>        In this equation, is a hazard function which is defined as the ratio of probability density over the run to the total value of probability densities [31][53][54]. The likelihood term represents the probability that the most recent datum belongs to current run. This is the most challenging term to calculate and it tends to be most computationally efficient when a conjugate exponential model is used [31].<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111055075.png" alt="image-20201127111055075"></p>
<p>在计算游程长度分布并更新了相应的统计信息之后，通过比较概率值执行更改点预测。如果rt在分布中具有最高概率，则发生了一个变化点，游程长度被重置为rt =0。否则，游程长度将增加1，rt = rt–1 + 1 [31] [53 ]。<br>        After calculating the run length distribution and updating the corresponding statistics, change point prediction is performed by comparing probability values. If rt has the highest probability in the distribution, then a change point has occurred and the run length is reset to rt = 0. If not, the run length is incremented by one, rt = rt–1 + 1 [31][53].<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111113156.png" alt="image-20201127111113156"></p>
<p>通过在方程中合并数据的不同子序列的可能性，该方法后来扩展到非i.d时间序列的一般情况。此外，引入了一种简化方法，可以使用简单的近似将算法复杂度从n2降低到n。关键思想是仅针对固定数量的节点计算联合概率权重，而不是在所有节点上计算这些权重[7]。<br>        This method was later extended to the general case of non i.i.d time series by incorporating the likelihood of different subsequences of data in the equations. In addition, a simplification was introduced that reduces the algorithm complexity from n2 to n using a simple approximation. The key idea is to compute the joint probability weights for only a fixed number of nodes, instead of computing these weights at all nodes [7].<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111126334.png" alt="image-20201127111126334"></p>
<p>高斯过程（GP）代表了另一种用于平稳时间序列分析和预测的概率方法[55]。 GP是高斯分布的概括，被定义为随机变量的集合，随机变量的任意数量均具有联合高斯分布[56] [57]。在这种方法中，时间序列观测值{xt}被定义为高斯分布函数值f（t）的噪声版本。<br>        A Gaussian Process (GP) represents another probabilistic method for stationary time series analysis and prediction [55]. A GP is a generalization of a Gaussian distribution and is defined as a collection of random variables, any finite number of which have a joint Gaussian distribution [56][57]. In this method, time series observations {xt} are defined as a noisy version of Gaussian distribution function values f(t).<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111141615.png" alt="image-20201127111141615"></p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111149437.png" alt="image-20201127111149437"></p>
<p>在此高斯分布函数中，εt是噪声项，通常假定为高斯噪声项，而f（t）=℘（0，K）是由均值零和协方差函数K指定的GP分布函数。通常，协方差使用一组超参数指定函数。广泛使用的协方差函数是：<br>        In this Gaussian distribution function, εt is a noise term, usually assumed to be a Gaussian noise term and f(t) = ℘(0, K) is a GP distribution function specified by mean zero and covariance function K. Typically, a covariance function is specified using a set of hyper-parameters. A widely used covariance function is:</p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111209383.png" alt="image-20201127111209383"></p>
<p>给定一个时间序列，可以使用GP函数在时间t进行正态分布预测。 GP Change算法使用高斯过程来估计时间t的预测分布，并使用整个时间（t − 1）的观测值。然后，该算法计算参考分布下的实际观测值yt的p值。阈值α∈（0,1）用于确定实际观测值何时不遵循预测分布，这表明可能的状态变化（从而指示变化点）[56]。使用时间t–1内可用的观测值来检测变化点，而不是仅使用上一个状态的观测值，使得GP方法比BCPD更复杂且更准确。<br>        Given a time series, the GP function can be used to make a normal distribution prediction at time t. The GP Change algorithm uses a Gaussian process to estimate the predictive distribution at time t using observations available through time (t − 1). The algorithm then computes the p-value for the actual observation yt under the reference distribution, . A threshold α ∈ (0,1) is used to determine when the actual observation does not follow the predictive distribution, which is indicative of a possible state change (and thus a change point) [56]. Using observations available through time t–1 to detect change points instead of using only observations from the last state makes the GP method more complicated and yet more accurate than BCPD.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111245970.png" alt="image-20201127111245970"></p>
<p>3.2.4基于内核的方法—尽管通常将基于内核的方法用作监督学习技术，但某些研究使用基于监督的无监督统计数据来测试过去和现在的滑动窗口在时间序列中的数据同质性。这些方法在与再现核k（。，。）和特征图Φ（X）= k（X，。）相关的再现核希尔伯特空间（RKHS）中映射观察结果[58]。然后，他们使用基于核Fisher判别比率的检验统计量作为窗口之间同质性的量度。<br>        3.2.4 Kernel Based Methods—Although kernel-based methods are typically utilized as supervised learning techniques, some studies use an unsupervised kernel-based test statistic to test the homogeneity of data in time series past and present sliding windows. These methods map the observations in a reproducing kernel Hilbert space (RKHS) ℋ associated with a reproducing kernel k(. , . ) and a feature map Φ(X) = k(X, . ) [58]. They then use a test statistic based upon the kernel Fisher discriminant ratio as a measure of homogeneity between windows.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111303342.png" alt="image-20201127111303342"></p>
<p>考虑两个观察窗口，长度为n的样本X的经验均值元素和协方差算子的计算公式为：<br>        Considering two windows of observations, the empirical mean elements and covariance operators for sample X with length n are calculated as:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111316065.png" alt="image-20201127111316065"></p>
<p>其中所有函数f∈ℋ的张量积算符u⊗v定义为（u⊗v）f = 〈v，f〉ℋu。现在，两个样本之间的核Fisher判别比率（KFDR）定义为[58] [24]：</p>
<p>其中γ是正则化参数，<br>        where γ is a regularization parameter and        where the tensor product operator u⊗v for all function f ∈ ℋ is defined as (u⊗v)f = 〈v, f〉ℋu. Now the kernel Fisher discriminant ratio (KFDR) between two samples is defined as [58][24]:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111331931.png" alt="image-20201127111331931"></p>
<p><img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111346844.png" alt="image-20201127111346844"></p>
<p>确定两个窗口之间是否存在变化点的最简单方法是将KFDR比率与阈值进行比较[58]。另一种称为运行最大分区策略的方法[24]计算每个间隔中所有后续窗口之间的KFDR比。然后，将最大比率与阈值进行比较以检测变化点。<br>        The easiest way to determine whether a change point exists between two windows is comparing the KFDR ratio with a threshold value [58]. The other method known as running maximum partition strategy [24] calculates the KFDR ratio between all consequent windows in each interval. Then the maximum ratio will be compared to threshold to detect change point.</p>
<p>基于内核的方法的一个共同缺点是，它们严重依赖于内核函数及其参数的选择，当数据处于中等至高维空间时，问题变得更加严重[23]。<br>        A common drawback for kernel-based methods is that they rely heavily on the choice of the kernel function and its parameters, and the problem becomes more severe when the data are in moderate to high dimensional spaces [23].</p>
<p>3.2.5基于图的方法-最近的一些研究表明，可以使用图论工具来研究时间序列。该图通常是从样本空间上的距离或广义相异性派生而来，其中时间序列观测值是节点，边缘是根据观测值的距离连接观测值的边缘。可以基于最小生成树[59]，最小距离对[60]，最近邻居图[59] [60]或可见性图[61] [62]定义此图。<br>        3.2.5 Graph Based Methods—Several recent studies showed time series can be investigated using graph theory tools. The graph is usually derived from a distance or a generalized dissimilarity on the sample space, with time series observations as nodes and edges connecting observations based on their distance. This graph can be defined based on a minimum spanning tree [59], minimum distance pairing [60], nearest neighbor graph [59] [60], or visibility graph [61][62].</p>
<p>基于图的变化点检测框架是一种非参数方法，该方法将两个样本测试应用于等效图，以发现观察值内是否存在变化点。在这种方法中，为每个数据序列构造图G。 τ作为变化点时间的每个可能值将观测分为两个窗口：τ之前的观测和τ之后的观测。连接来自这两个窗口的观察值的图形G（RG）中的边数用作更改点的指示符，因此，较小的边会增加更改点的可能性。由于RG的值取决于时间t，因此标准化函数（ZG）定义为：<br>        A graph based framework for change point detection is a nonparametric approach that applies a two sample test on an equivalent graph to find whether there is a change point within the observations or not. In this method graph G is constructed for each sequence of data. Each possible value of τ as change point time divides the observations into two windows: observations that come before τ and observations that come after τ. The number of edges in the graph G (RG) that connects observations from these two windows is used as an indicator of a change point, so that smaller edges increase the possibility of change point. Since the value of RG depends on time t, the standardized function (ZG) is defined as:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111647067.png" alt="image-20201127111647067"></p>
<p>其中E [。 ]和V AR [。 ]分别是期望值和方差。将图中所有数据点中的ZG最大值标识为候选更改点。如果最大值大于指定的阈值，则接受更改点[23]。对于较少参数假设的高维数据，此方法功能强大。但是，它没有利用来自时间序列观测值本身的大量信息，而是依靠定义适当的图结构。<br>        where E[. ] and V AR[. ] are Expectation and V ariance, respectively. The maximum value of ZG among all data points in the graph is identified as a candidate change point. The change point is accepted if the maxima is greater than a specified threshold [23]. This method is powerful for high dimensional data with fewer parameter assumptions. However, it does not utilize much information from the time series observations themselves, instead relying on defining an appropriate graph structure.</p>
<p>3.2.6聚类方法-从不同的角度来看，变化点检测的问题可以视为具有已知或未知数目的聚类的聚类问题，这样，聚类内的观测值将被均匀分布，而相邻聚类之间的观测则不会。如果时间戳t处的数据点与时间戳t + 1处的数据点属于不同的群集，则在两个观测值之间会出现一个变化点。<br>        3.2.6 Clustering Methods—From a different perspective, the problem of change point detection can be considered as a clustering problem with a known or unknown number of clusters, such that observations within clusters are identically distributed, and observations between adjacent clusters are not. If a data point at time stamp t belongs to a different cluster than the data point at time stamp t+1, then a change point occurs between the two observations.</p>
<p>一种用于变化点检测的聚类方法将滑动窗口和自下而上的方法组合为一种称为SW AB（滑动窗口和自下而上）的算法[63]。原始的自下而上的方法首先将每个数据点视为一个单独的子序列，然后将子序列与相关合并成本合并，直到满足停止条件为止。相比之下，SW AB保持大小为w的缓冲区以存储足够的数据用于5-6个子序列。自底向上方法应用于缓冲区中的数据，并报告最左边的结果子序列。从缓冲区中删除与报告的子序列相对应的数据，并用系列中的下一个数据替换。<br>        One clustering approach used for change point detection combines sliding window and bottom up methods into an algorithm called SW AB (Sliding Window and Bottom-up) [63]. The original bottom-up approach first treats each data point as a separate subsequence, then merges subsequences with an associate merge cost until the stopping criteria is met. In contrast, SW AB maintains a buffer of size w to store enough data for 5 – 6 subsequences. The bottom-up method is applied to the data in the buffer and the leftmost resulting subsequence is reported. The data corresponding to the reported subsequence are removed from the buffer and replaced with the next data in the series.</p>
<p>第二种聚类方法基于最小描述长度[32]对子序列进行分组。长度为m的时间序列T的描述长度DL是表示该序列所需的总位数，或者：<br>        A second clustering approach groups subsequences based on Minimum Description Length [32]. The description length DL of a time series T of length m is the total number of bits that are required to represent the series, or:<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111823305.png" alt="image-20201127111823305"></p>
<p>其中H（T）是时间序列的熵。<br>        where H(T) is the entropy of the time series.</p>
<p>基于MDL的更改点检测是对群集空间进行的自下而上的贪婪搜索，其中可能包括不同长度的子序列，并且不需要指定群集的数量。此方法将枚举的图案而不是所有子序列聚类。<br>        MDL-based change point detection is a bottom-up greedy search over the space of clusters which can include subsequences of different lengths and does not require the number of clusters to be specified. This method clusters enumerated motifs instead of all the subsequences.</p>
<p>找到时间序列主题之后，将应用三个搜索运算符：创建（创建新集群），添加（向现有集群添加子序列）和合并（合并两个集群）。 bitsave的值表示通过将这些运算符之一应用于时间序列而节省的总位数。<br>        After finding time series motifs, three search operators are applied: create (create a new cluster), add (add a subsequence to an existing cluster), and merge (merge two clusters). The value of bitsave represents the total number of bits that are saved by applying one of these operators to the time series.<img src="C:\Users\benenzhu\AppData\Roaming\Typora\typora-user-images\image-20201127111854126.png" alt="image-20201127111854126"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2020/11/27/A-survey-of-Methods-for-Time-Series/">http://example.com/2020/11/27/A-survey-of-Methods-for-Time-Series/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/11/19/%E4%BB%8E%E5%8F%8D%E5%A4%8D%E6%97%A0%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0-%E4%B8%80%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">从反复无常的数据流中进行在线学习:一种生成方法</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abs"><span class="toc-number">1.</span> <span class="toc-text">Abs:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#intro"><span class="toc-number">2.</span> <span class="toc-text">intro</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#background"><span class="toc-number">3.</span> <span class="toc-text">background</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E9%97%AE%E9%A2%98%E8%A1%A8%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">定义和问题表述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86-Criteria"><span class="toc-number">3.2.</span> <span class="toc-text">标准 Criteria</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%E5%9C%A8%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1在线检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2可伸缩性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3%E7%AE%97%E6%B3%95%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3算法约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E7%BB%A9%E6%95%88%E8%AF%84%E4%BC%B0"><span class="toc-number">3.3.</span> <span class="toc-text">2.3绩效评估</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#review"><span class="toc-number">4.</span> <span class="toc-text">review</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">监督方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%9B%91%E7%9D%A3%E6%96%B9%E6%B3%95-Unsupervised-Methods"><span class="toc-number">4.2.</span> <span class="toc-text">无监督方法 Unsupervised Methods</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/11/27/A-survey-of-Methods-for-Time-Series/" title="A_survey_of_Methods_for_Time_Series"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A_survey_of_Methods_for_Time_Series"/></a><div class="content"><a class="title" href="/2020/11/27/A-survey-of-Methods-for-Time-Series/" title="A_survey_of_Methods_for_Time_Series">A_survey_of_Methods_for_Time_Series</a><time datetime="2020-11-27T02:48:30.000Z" title="Created 2020-11-27 10:48:30">2020-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/19/%E4%BB%8E%E5%8F%8D%E5%A4%8D%E6%97%A0%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0-%E4%B8%80%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/" title="从反复无常的数据流中进行在线学习:一种生成方法"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从反复无常的数据流中进行在线学习:一种生成方法"/></a><div class="content"><a class="title" href="/2020/11/19/%E4%BB%8E%E5%8F%8D%E5%A4%8D%E6%97%A0%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0-%E4%B8%80%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/" title="从反复无常的数据流中进行在线学习:一种生成方法">从反复无常的数据流中进行在线学习:一种生成方法</a><time datetime="2020-11-19T13:01:07.000Z" title="Created 2020-11-19 21:01:07">2020-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/19/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0advances-and-open-problems-in-Federated-learning/" title="联邦学习综述advances_and_open_problems_in_Federated_learning"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="联邦学习综述advances_and_open_problems_in_Federated_learning"/></a><div class="content"><a class="title" href="/2020/11/19/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0advances-and-open-problems-in-Federated-learning/" title="联邦学习综述advances_and_open_problems_in_Federated_learning">联邦学习综述advances_and_open_problems_in_Federated_learning</a><time datetime="2020-11-19T07:30:07.000Z" title="Created 2020-11-19 15:30:07">2020-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/19/%E8%AE%B2%E5%BA%A7-%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/" title="讲座-联邦学习综述"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="讲座-联邦学习综述"/></a><div class="content"><a class="title" href="/2020/11/19/%E8%AE%B2%E5%BA%A7-%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/" title="讲座-联邦学习综述">讲座-联邦学习综述</a><time datetime="2020-11-19T06:20:49.000Z" title="Created 2020-11-19 14:20:49">2020-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/18/005-A-Survey-on-Concept-Drift-Adaptation/" title="005_A_Survey_on_Concept_Drift_Adaptation"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="005_A_Survey_on_Concept_Drift_Adaptation"/></a><div class="content"><a class="title" href="/2020/11/18/005-A-Survey-on-Concept-Drift-Adaptation/" title="005_A_Survey_on_Concept_Drift_Adaptation">005_A_Survey_on_Concept_Drift_Adaptation</a><time datetime="2020-11-18T08:40:55.000Z" title="Created 2020-11-18 16:40:55">2020-11-18</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>